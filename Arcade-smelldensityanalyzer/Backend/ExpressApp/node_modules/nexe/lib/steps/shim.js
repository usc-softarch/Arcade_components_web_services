"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
function default_1(compiler, next) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, next()];
                case 1:
                    _a.sent();
                    compiler.shims.push(util_1.wrap("process.__nexe = " + JSON.stringify(compiler.binaryConfiguration) + ";\n" +
                        "\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar originalFsMethods = null;\nvar lazyRestoreFs = function () { };\n// optional Win32 file namespace prefix followed by drive letter and colon\nvar windowsFullPathRegex = /^(\\\\{2}\\?\\\\)?([a-zA-Z]):/;\nvar upcaseDriveLetter = function (s) {\n    return s.replace(windowsFullPathRegex, function (_match, ns, drive) { return \"\" + (ns || '') + drive.toUpperCase() + \":\"; });\n};\nfunction shimFs(binary, fs) {\n    if (fs === void 0) { fs = require('fs'); }\n    if (originalFsMethods !== null) {\n        return;\n    }\n    originalFsMethods = Object.assign({}, fs);\n    var blobPath = binary.blobPath, manifest = binary.resources, _a = binary.layout, resourceStart = _a.resourceStart, stat = _a.stat, directories = {}, notAFile = '!@#$%^&*', isWin = process.platform.startsWith('win'), isString = function (x) { return typeof x === 'string' || x instanceof String; }, noop = function () { }, path = require('path'), winPath = isWin ? upcaseDriveLetter : function (s) { return s; }, baseDir = winPath(path.dirname(process.execPath));\n    var log = function (_) { return true; };\n    var loggedManifest = false;\n    if ((process.env.DEBUG || '').toLowerCase().includes('nexe:require')) {\n        log = function (text) {\n            setupManifest();\n            if (!loggedManifest) {\n                process.stderr.write('[nexe] - MANIFEST' + JSON.stringify(manifest, null, 4) + '\\n');\n                process.stderr.write('[nexe] - DIRECTORIES' + JSON.stringify(directories, null, 4) + '\\n');\n                loggedManifest = true;\n            }\n            return process.stderr.write('[nexe] - ' + text + '\\n');\n        };\n    }\n    var getKey = function getKey(filepath) {\n        if (Buffer.isBuffer(filepath)) {\n            filepath = filepath.toString();\n        }\n        if (!isString(filepath)) {\n            return notAFile;\n        }\n        var key = path.resolve(baseDir, filepath);\n        return winPath(key);\n    };\n    var statTime = function () {\n        return {\n            dev: 0,\n            ino: 0,\n            nlink: 0,\n            rdev: 0,\n            uid: 123,\n            gid: 500,\n            blksize: 4096,\n            blocks: 0,\n            atime: new Date(stat.atime),\n            atimeMs: stat.atime.getTime(),\n            mtime: new Date(stat.mtime),\n            mtimeMs: stat.mtime.getTime(),\n            ctime: new Date(stat.ctime),\n            ctimMs: stat.ctime.getTime(),\n            birthtime: new Date(stat.birthtime),\n            birthtimeMs: stat.birthtime.getTime(),\n        };\n    };\n    var BigInt;\n    try {\n        BigInt = eval('BigInt');\n    }\n    catch (ignored) { }\n    var createStat = function (extensions, options) {\n        var stat = Object.assign(new fs.Stats(), binary.layout.stat, statTime(), extensions);\n        if (options && options.bigint && BigInt) {\n            for (var k in stat) {\n                if (Object.prototype.hasOwnProperty.call(stat, k) && typeof stat[k] === 'number') {\n                    stat[k] = BigInt(stat[k]);\n                }\n            }\n        }\n        return stat;\n    };\n    var ownStat = function (filepath, options) {\n        setupManifest();\n        var key = getKey(filepath);\n        if (directories[key]) {\n            var mode = binary.layout.stat.mode;\n            mode |= fs.constants.S_IFDIR;\n            mode &= ~fs.constants.S_IFREG;\n            return createStat({ mode: mode, size: 0 }, options);\n        }\n        if (manifest[key]) {\n            return createStat({ size: manifest[key][1] }, options);\n        }\n    };\n    function makeLong(filepath) {\n        return path._makeLong && path._makeLong(filepath);\n    }\n    function fileOpts(options) {\n        return !options ? {} : isString(options) ? { encoding: options } : options;\n    }\n    var setupManifest = function () {\n        Object.keys(manifest).forEach(function (filepath) {\n            var entry = manifest[filepath];\n            var absolutePath = getKey(filepath);\n            var longPath = makeLong(absolutePath);\n            var normalizedPath = winPath(path.normalize(filepath));\n            if (!manifest[absolutePath]) {\n                manifest[absolutePath] = entry;\n            }\n            if (longPath && !manifest[longPath]) {\n                manifest[longPath] = entry;\n            }\n            if (!manifest[normalizedPath]) {\n                manifest[normalizedPath] = manifest[filepath];\n            }\n            var currentDir = path.dirname(absolutePath);\n            var prevDir = absolutePath;\n            while (currentDir !== prevDir) {\n                directories[currentDir] = directories[currentDir] || {};\n                directories[currentDir][path.basename(prevDir)] = true;\n                var longDir = makeLong(currentDir);\n                if (longDir && !directories[longDir]) {\n                    directories[longDir] = directories[currentDir];\n                }\n                prevDir = currentDir;\n                currentDir = path.dirname(currentDir);\n            }\n        });\n        manifest[notAFile] = false;\n        directories[notAFile] = false;\n        setupManifest = noop;\n    };\n    //naive patches intended to work for most use cases\n    var nfs = {\n        existsSync: function existsSync(filepath) {\n            setupManifest();\n            var key = getKey(filepath);\n            if (manifest[key] || directories[key]) {\n                return true;\n            }\n            return originalFsMethods.existsSync.apply(fs, arguments);\n        },\n        realpath: function realpath(filepath, options, cb) {\n            setupManifest();\n            var key = getKey(filepath);\n            if (isString(filepath) && (manifest[filepath] || manifest[key])) {\n                return process.nextTick(function () { return cb(null, filepath); });\n            }\n            return originalFsMethods.realpath.call(fs, filepath, options, cb);\n        },\n        realpathSync: function realpathSync(filepath, options) {\n            setupManifest();\n            var key = getKey(filepath);\n            if (manifest[key]) {\n                return filepath;\n            }\n            return originalFsMethods.realpathSync.call(fs, filepath, options);\n        },\n        readdir: function readdir(filepath, options, callback) {\n            setupManifest();\n            var dir = directories[getKey(filepath)];\n            if (dir) {\n                if ('function' === typeof options) {\n                    callback = options;\n                    options = { encoding: 'utf8' };\n                }\n                process.nextTick(function () { return callback(null, Object.keys(dir)); });\n            }\n            else {\n                return originalFsMethods.readdir.apply(fs, arguments);\n            }\n        },\n        readdirSync: function readdirSync(filepath, options) {\n            setupManifest();\n            var dir = directories[getKey(filepath)];\n            if (dir) {\n                return Object.keys(dir);\n            }\n            return originalFsMethods.readdirSync.apply(fs, arguments);\n        },\n        readFile: function readFile(filepath, options, callback) {\n            setupManifest();\n            var entry = manifest[getKey(filepath)];\n            if (!entry) {\n                return originalFsMethods.readFile.apply(fs, arguments);\n            }\n            var offset = entry[0], length = entry[1];\n            var resourceOffset = resourceStart + offset;\n            var encoding = fileOpts(options).encoding;\n            callback = typeof options === 'function' ? options : callback;\n            originalFsMethods.open(blobPath, 'r', function (err, fd) {\n                if (err)\n                    return callback(err, null);\n                originalFsMethods.read(fd, Buffer.alloc(length), 0, length, resourceOffset, function (error, bytesRead, result) {\n                    if (error) {\n                        return originalFsMethods.close(fd, function () {\n                            callback(error, null);\n                        });\n                    }\n                    originalFsMethods.close(fd, function (err) {\n                        if (err) {\n                            return callback(err, result);\n                        }\n                        callback(err, encoding ? result.toString(encoding) : result);\n                    });\n                });\n            });\n        },\n        createReadStream: function createReadStream(filepath, options) {\n            setupManifest();\n            var entry = manifest[getKey(filepath)];\n            if (!entry) {\n                return originalFsMethods.createReadStream.apply(fs, arguments);\n            }\n            var offset = entry[0], length = entry[1];\n            var resourceOffset = resourceStart + offset;\n            var opts = fileOpts(options);\n            return originalFsMethods.createReadStream(blobPath, Object.assign({}, opts, {\n                start: resourceOffset,\n                end: resourceOffset + length - 1,\n            }));\n        },\n        readFileSync: function readFileSync(filepath, options) {\n            setupManifest();\n            var entry = manifest[getKey(filepath)];\n            if (!entry) {\n                return originalFsMethods.readFileSync.apply(fs, arguments);\n            }\n            var offset = entry[0], length = entry[1];\n            var resourceOffset = resourceStart + offset;\n            var encoding = fileOpts(options).encoding;\n            var fd = originalFsMethods.openSync(process.execPath, 'r');\n            var result = Buffer.alloc(length);\n            originalFsMethods.readSync(fd, result, 0, length, resourceOffset);\n            originalFsMethods.closeSync(fd);\n            return encoding ? result.toString(encoding) : result;\n        },\n        statSync: function statSync(filepath, options) {\n            var stat = ownStat(filepath, options);\n            if (stat) {\n                return stat;\n            }\n            return originalFsMethods.statSync.apply(fs, arguments);\n        },\n        stat: function stat(filepath, options, callback) {\n            var stat;\n            if (typeof options === 'function') {\n                callback = options;\n                stat = ownStat(filepath, null);\n            }\n            else {\n                stat = ownStat(filepath, options);\n            }\n            if (stat) {\n                process.nextTick(function () {\n                    callback(null, stat);\n                });\n            }\n            else {\n                return originalFsMethods.stat.apply(fs, arguments);\n            }\n        },\n    };\n    if (typeof fs.exists === 'function') {\n        nfs.exists = function (filepath, cb) {\n            cb = cb || noop;\n            var exists = nfs.existsSync(filepath);\n            process.nextTick(function () { return cb(exists); });\n        };\n    }\n    var patches = process.nexe.patches || {};\n    delete process.nexe;\n    patches.internalModuleReadFile = function (original) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        setupManifest();\n        var filepath = getKey(args[0]);\n        if (manifest[filepath]) {\n            log('read     (hit)              ' + filepath);\n            return nfs.readFileSync(filepath, 'utf-8');\n        }\n        log('read          (miss)       ' + filepath);\n        return original.call.apply(original, __spreadArrays([this], args));\n    };\n    patches.internalModuleReadJSON = patches.internalModuleReadFile;\n    patches.internalModuleStat = function (original) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        setupManifest();\n        var filepath = getKey(args[0]);\n        if (manifest[filepath]) {\n            log('stat     (hit)              ' + filepath + '   ' + 0);\n            return 0;\n        }\n        if (directories[filepath]) {\n            log('stat dir (hit)              ' + filepath + '   ' + 1);\n            return 1;\n        }\n        var res = original.call.apply(original, __spreadArrays([this], args));\n        if (res === 0) {\n            log('stat          (miss)        ' + filepath + '   ' + res);\n        }\n        else if (res === 1) {\n            log('stat dir      (miss)        ' + filepath + '   ' + res);\n        }\n        else {\n            log('stat                 (fail) ' + filepath + '   ' + res);\n        }\n        return res;\n    };\n    if (typeof fs.exists === 'function') {\n        nfs.exists = function (filepath, cb) {\n            cb = cb || noop;\n            var exists = nfs.existsSync(filepath);\n            if (!exists) {\n                return originalFsMethods.exists(filepath, cb);\n            }\n            process.nextTick(function () { return cb(exists); });\n        };\n    }\n    if (typeof fs.copyFile === 'function') {\n        nfs.copyFile = function (filepath, dest, flags, callback) {\n            setupManifest();\n            var entry = manifest[getKey(filepath)];\n            if (!entry) {\n                return originalFsMethods.copyFile.apply(fs, arguments);\n            }\n            if (typeof flags === 'function') {\n                callback = flags;\n                flags = 0;\n            }\n            nfs.readFile(filepath, function (err, buffer) {\n                if (err) {\n                    return callback(err);\n                }\n                originalFsMethods.writeFile(dest, buffer, function (err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    callback(null);\n                });\n            });\n        };\n        nfs.copyFileSync = function (filepath, dest) {\n            setupManifest();\n            var entry = manifest[getKey(filepath)];\n            if (!entry) {\n                return originalFsMethods.copyFileSync.apply(fs, arguments);\n            }\n            return originalFsMethods.writeFileSync(dest, nfs.readFileSync(filepath));\n        };\n    }\n    Object.assign(fs, nfs);\n    lazyRestoreFs = function () {\n        Object.keys(nfs).forEach(function (key) {\n            fs[key] = originalFsMethods[key];\n        });\n        lazyRestoreFs = function () { };\n    };\n    return true;\n}\nexports.shimFs = shimFs;\nfunction restoreFs() {\n    lazyRestoreFs();\n}\nexports.restoreFs = restoreFs;\n" +
                        '\nshimFs(process.__nexe)' +
                        ("\n" + (compiler.options.fs ? '' : 'restoreFs()'))
                    //TODO support only restoring specific methods
                    ));
                    compiler.shims.push(util_1.wrap("\n    if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n      const cluster = require('cluster')\n      cluster._setupWorker()\n      delete process.env.NODE_UNIQUE_ID\n    }\n  "));
                    compiler.shims.push(util_1.wrap("\n      if (!process.send) {\n        const path = require('path')\n        const entry = path.resolve(path.dirname(process.execPath)," + JSON.stringify(compiler.entrypoint) + ")\n        process.argv.splice(1,0, entry)\n      }\n    "));
                    return [2 /*return*/];
            }
        });
    });
}
exports.default = default_1;
